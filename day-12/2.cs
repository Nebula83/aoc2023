class Day2
{
    private List<string> ReadFile(string name)
    {
        List<string> lines = new List<string>();
        string? line;
        try
        {
            //Pass the file path and file name to the StreamReader constructor
            StreamReader sr = new StreamReader(name);
            //Read the first line of text
            line = sr.ReadLine();
            //Continue to read until you reach end of file
            while (line != null)
            {
                //write the line to console window
                lines.Add(line);
                //Read the next line
                line = sr.ReadLine();
            }
            //close the file
            sr.Close();
        }
        catch(Exception e)
        {
            Console.WriteLine("Exception: " + e.Message);
            throw;
        }

        return lines;
    }

    private List<(string, List<int>)> ParseLines(List<string> lines)
    {
        var data = new List<(string, List<int>)>();
        foreach (var line in lines)
        {
            var parts = line.Split(' ');
            var broken = parts[1].Split(',').Select(s => int.Parse(s)).ToList();

            // "unfold"
            var unfoldedParts = new List<string>();
            var unfoldedBroken = new List<int>();
            for (int unfold = 0; unfold < 5; unfold++)
            {
                unfoldedParts.Add(parts[0]);
                unfoldedBroken.AddRange(broken);
            }

            data.Add((string.Join("?", unfoldedParts), unfoldedBroken));
        }

        return data;
    }


    internal static void Run()
    {
        var day = new Day2();
        // var lines = day.ReadFile("test-1.txt");
        var lines = day.ReadFile("input.txt");
        var options = day.ParseLines(lines);
        var result = 0L;

        foreach (var (record, broken) in options)
        {
            // First, generate the base solution
            string states = GenerateBaseSolution(broken);
            // Start in the first 'state', which is always a '.' , as generated by 
            // the base solution.
            var currentStates = new Dictionary<int, long>{{0, 1}};
            var newStates = new Dictionary<int, long>();

            // Now traverse the records, and check how we can fit the base solution onto it.
            foreach (var r in record)
            {
                // Update the current state using the record, however, since it's an 
                // Nondeterministic Finite Automata, the current state can be many.
                foreach (var state in currentStates.Keys)
                {
                    // If the character is a '?' it can either be a(nother) '.' or a '#'. 
                    if (r == '?')
                    {
                        // Transition if we can and raise the counter if we already went here.
                        if (state + 1 < states.Length)
                        {
                            newStates[state + 1] = newStates.GetValueOrDefault(state + 1) + currentStates[state];
                        }
                        // If the current state is a '.', raise the counter if we already went here.
                        if (states[state] == '.')
                        {
                            newStates[state] = newStates.GetValueOrDefault(state) + currentStates[state];
                        }
                    }
                    // If the character is a '.', stay in the state or see if we can proceed
                    else if (r == '.')
                    {
                        // Transition only if the reference allows for a '.'. Raise the counter if we already went here.
                        if ((state + 1 < states.Length) && (states[state + 1] == '.'))
                        {
                            newStates[state + 1] = newStates.GetValueOrDefault(state + 1) + currentStates[state];
                        }
                        // If the current state is a '.', raise the counter if we already went here.
                        if (states[state] == '.')
                        {
                            newStates[state] = newStates.GetValueOrDefault(state) + currentStates[state];
                        }
                    } 
                    // If the character is a '#', it's meaning is known
                    else if (r == '#')
                    {
                        // If the reference allow a transition to '#' then remember, otherwise ditch this branch.
                        if ((state + 1 < states.Length) && (states[state + 1] == '#'))
                        {
                            newStates[state + 1] = newStates.GetValueOrDefault(state + 1) + currentStates[state];
                        }
                    }
                }
            
                currentStates = newStates;
                newStates = new Dictionary<int, long>();
            }

            // The result is either one of the end states: with or without trailing '.'
            result += currentStates.GetValueOrDefault(states.Length - 1) + currentStates.GetValueOrDefault(states.Length - 2);
        }

        Console.WriteLine($"Result 2: {result}");
    }

    private static string GenerateBaseSolution(List<int> broken)
    {
        var states = "."; // Primary state is not broken since this will always hold true
        foreach (var section in broken)
        {
            for (int index = 0; index < section; index++)
            {
                states += '#';
            }
            states += '.';
        }

        return states;
    }
}
